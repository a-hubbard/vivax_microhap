---
title: Tidying of Microhaplotype Results
author: Alfred Hubbard
output:
  html_notebook: default
  pdf_document: default
  github_document: default
---

```{r setup, echo = FALSE, message = FALSE, warning = FALSE}
# Load required libraries ----------------------------------------------
# These will be referenced without the `package::` construct, and thus 
# are loaded second to avoid masking
library(dplyr)
library(ggplot2)
library(knitr)
library(magrittr)
library(readr)
library(readxl)
library(stringr)
library(tibble)
library(tidyr)

# Don't include code in PDF output
opts_chunk$set(echo = ! is_latex_output(), out.width = "100%")
# Set default ggplot2 theme
theme_set(theme_bw())

# Hardcode parameters. These are not passed as shell arguments because 
# hardcoded values facilitate development and this document is not 
# meant to be usable with other projects.
inp <- list(
  seqtab = "../../results/AmpSeq/asv2cigar/seqtab_cigar.tsv", 
  asv2cigar = "../../results/AmpSeq/asv2cigar/asv2cigar_tab.tsv", 
  trg_coords = 
    "../../results/primer_mapping/captured_seq_coords_noprimers.bed", 
  vera_lane_summary = "../../resources/vera_lane_summary.csv", 
  vera_library = 
    "../../resources/vera_library_2023-03-18_HemmingSchroeder_UCDavis.csv", 
  pv_samples_idaho = "../../resources/Pv_samples_Idaho.csv", 
  gbpcd_meta = "../../resources/GBPCD_meta.csv", 
  gbpcd_matched = "../../resources/GBPCD_P01_DBS_072423-Matched.xlsx"
)
out <- list(microhap_tidy = "../../results/microhap/microhap.csv")
```

# Missing Data by Marker

```{r}
# Read in final, filtered data -----------------------------------------
seqtab <- read_tsv(
    inp$seqtab, 
    col_types = cols(.default = col_integer(), sample = col_character()), 
    progress = FALSE
  ) %>%
  pivot_longer(-sample, names_to = "target_cigar", values_to = "n_read") %>%
  separate_wider_delim(target_cigar, ",", names = c("target", "cigar")) %>%
  rename(sample_id = sample)

# Read and join ASV IDs ------------------------------------------------
asv2cigar <- read_tsv(
  inp$asv2cigar, 
  col_types = cols(.default = col_character()), 
  progress = FALSE
)
mh_data <- seqtab %>%
  left_join(
    asv2cigar, 
    by = c("target" = "Amplicon", "cigar" = "CIGAR"), 
    relationship = "many-to-many"
  )

# Compute number of samples with data for each loci --------------------
n_samp_wdata <- mh_data %>%
  group_by(target, sample_id) %>%
  summarize(n_read = sum(n_read), .groups = "drop") %>%
  group_by(target) %>%
  summarize(n_samp_wdata = sum(n_read > 0), .groups = "drop")
mh_data <- mh_data %>%
  left_join(n_samp_wdata, by = "target")

# Plot data quantity by marker -----------------------------------------
n_samp_wdata_thres <- 20
mh_data %>%
  select(target, n_samp_wdata) %>%
  distinct() %>%
  ggplot(mapping = aes(x = n_samp_wdata)) +
  geom_histogram(bins = 25) +
  geom_vline(xintercept = n_samp_wdata_thres, color = "blue") +
  labs(x = "No. of Samples With Data", y = "No. of Markers")
```

This histogram shows the distribution of markers according to how many samples
have data for each marker. Given that the total number of samples in the dataset
is `r n_distinct(mh_data$sample_id)`, these results are pretty good. Many
markers have data for all of the samples, and about half of the rest have data
for more than half of the samples.

A few markers, though, did not perform well. The vertical blue line marks `r 
n_samp_wdata_thres` samples with data. This threshold is used to filter markers 
for subsequent analyses, removing those that fall below.

```{r}
# Filter out loci with lots of missing data ----------------------------
mh_data_filtered <- mh_data %>%
  filter(n_samp_wdata >= n_samp_wdata_thres)
```

# Missing Data by Sample

```{r}
# Compute number of loci with data for each sample ---------------------
n_trg_wdata <- mh_data_filtered %>%
  group_by(target, sample_id) %>%
  summarize(n_read = sum(n_read), .groups = "drop") %>%
  group_by(sample_id) %>%
  summarize(n_trg_wdata = sum(n_read > 0), .groups = "drop")
mh_data_filtered <- mh_data_filtered %>%
  left_join(n_trg_wdata, by = "sample_id")

# Plot distribution of missing data proportion by marker ---------------
# This threshold guarantees ten markers worth of overlap between any 
# two samples
n_trg_wdata_thres <- round((n_distinct(mh_data_filtered$target)/2) + 10)
mh_data_filtered %>%
  select(sample_id, n_trg_wdata) %>%
  distinct() %>%
  ggplot(mapping = aes(x = n_trg_wdata)) +
  geom_histogram(bins = 20) +
  geom_vline(xintercept = n_trg_wdata_thres, color = "blue") +
  labs(x = "No. of Targets With Data", y = "No. of Samples")
```

This histogram shows the distribution of samples according to how many markers
have data for each sample. Note the marker filter of `r n_samp_wdata_thres` 
samples with data has already been applied, and this histogram is based on the 
remaining data. There are `r n_distinct(mh_data_filtered$target)` markers left 
in the dataset after the filtering above. This histogram shows that almost all 
of the samples have data for most of these markers.

The vertical blue line shows the chosen threshold of targets with data that will 
be used for filtering the samples. This value, `r n_trg_wdata_thres`, was 
selected with the following formula, rounding up:

$$
Thres. = \frac{No. Targets}{2} + 10
$$

This threshold ensures that every pair of samples has a minimum of 10 targets 
worth of overlap, hopefully ensuring sufficient data for relatedness analysis. 
The blue line indicates only two samples will be removed by applying this 
threshold.

```{r}
# Filter out loci with lots of missing data ----------------------------
mh_data_filtered <- mh_data_filtered %>%
  filter(n_trg_wdata >= n_trg_wdata_thres) %>%
  # Remove explicit missing data
  filter(n_read > 0)
```

# Stats

Number of markers in the filtered dataset:

```{r}
n_distinct(mh_data_filtered$target)
```

Number of samples in the filtered dataset:

```{r}
n_distinct(mh_data_filtered$sample_id)
```

```{r}
# Read in and join chromosome information ------------------------------
chrom_info <- read_tsv(
    inp$trg_coords, 
    col_names = c("chrom", "start_pos", "end_pos", "target"), 
    col_types = cols(
      .default = col_character(), 
      start_pos = col_integer(), 
      end_pos = col_integer()
    ), 
    progress = FALSE
  ) %>%
  select(chrom, target)
mh_data_filtered <- mh_data_filtered %>%
  left_join(chrom_info, by = "target")

# Read in sample metadata ----------------------------------------------
vera_lane_summary <- read_csv(
    inp$vera_lane_summary, 
    col_types = cols(.default = col_character()), 
    progress = FALSE
  ) %>%
  filter(str_detect(Sample, "OLD")) %>%
  separate(`Barcode sequence`, c("i7_seq", "i5_seq"), sep = "\\+")
vera_library <- read_csv(
    inp$vera_library, 
    col_names = c(
      "tube", 
      "lib_name", 
      "well", 
      "i7_name", 
      "i7_seq", 
      "i5_name", 
      "i5_seq"
    ), 
    col_types = cols(.default = col_character()), 
    skip = 1, 
    progress = FALSE
  ) %>%
  filter(str_detect(lib_name, "old")) %>%
  select(well, i7_seq, i5_seq)
pv_samples_idaho <- read_csv(
    inp$pv_samples_idaho, 
    col_types = cols(
      .default = col_double(), 
      SeqPlate_Well = col_character(), 
      `Sample Name` = col_character(), 
      Dilution = col_character()
    ), 
    progress = FALSE
  ) %>%
  mutate(SeqPlate_Well = str_sub(SeqPlate_Well, start = 4L)) %>%
  rename(UCI_SID = `Sample Name`)
gbpcd_meta <- read_csv(
  inp$gbpcd_meta, 
  col_types = cols(.default = col_character(), Age = col_integer()), 
  progress = FALSE
)
gbpcd_matched <- read_excel(inp$gbpcd_matched)

# Join sample metadata into one tibble, then to microhaplotypes --------
sample_metadata <- left_join(
    vera_lane_summary, 
    vera_library, 
    by = c("i7_seq", "i5_seq")
  ) %>%
  select(-i7_seq, -i5_seq) %>%
  left_join(pv_samples_idaho, by = c("well" = "SeqPlate_Well")) %>%
  left_join(gbpcd_matched, by = "UCI_SID")
  # left_join(gbpcd_meta, by = "UCI_SID")
filter(sample_metadata, is.na(DBS_ID))

mh_data_filtered <- mh_data_filtered %>%
  left_join(sample_metadata, by = c("sample_id" = "Sample")) %>%
  mutate(pop = str_split_i(DBS_ID, "-", 1))

# Save filtered data ---------------------------------------------------
mh_data_filtered %>%
  # Calculate MOI. It would be more logical to do this in moi.Rmd, but 
  # that would complicate the pipeline.
  group_by(sample_id, target) %>%
  mutate(n_hap = n()) %>%
  ungroup() %>%
  group_by(sample_id) %>%
  mutate(moi = max(n_hap)) %>%
  ungroup() %>%
  write_csv(out$microhap_tidy)
```
