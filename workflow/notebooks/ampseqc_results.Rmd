---
title: Visualization of Read Counts from AmpSeQC
author: Alfred Hubbard
output:
  html_notebook: default
  pdf_document: default
  github_document: default
---

```{r setup, echo = FALSE, message = FALSE, warning = FALSE}
# Load required libraries ----------------------------------------------
# These will be referenced without the `package::` construct, and thus 
# are loaded second to avoid masking
library(dplyr)
library(ggplot2)
library(knitr)
library(magrittr)
library(purrr)
library(readr)
library(stringr)
library(tidyr)

# Don't include code in PDF output
opts_chunk$set(echo = ! is_latex_output(), out.width = "100%")
# Set default ggplot2 theme
theme_set(theme_bw())

# Hardcode parameters. These are not passed as shell arguments because 
# hardcoded values facilitate development and this document is not 
# meant to be usable with other projects.
inp <- list(
  may2022_read_counts = "../../results/AmpSeQC/May2022/read_counts.tsv", 
  uci1223_read_counts = "../../results/AmpSeQC/UCI1223/read_counts.tsv", 
  serialdil_read_counts = "../../results/AmpSeQC/serialdil/read_counts.tsv"
)
out <- list(loci_good_amp = "../../results/loci2filter/good_amp.csv")
```

# Read Counts

## May 2022

```{r message = FALSE}
plot_failed_reads <- function(read_counts) {
  read_counts %>%
    select(
      sample_id, 
      `__no_feature`, 
      `__ambiguous`, 
      `__too_low_aQual`, 
      `__not_aligned`, 
      `__alignment_not_unique`
    ) %>%
    pivot_longer(-sample_id, names_to = "reason", values_to = "n_read") %>%
    ggplot(mapping = aes(x = n_read)) +
    geom_histogram(bins = 30) +
    facet_wrap(vars(reason)) +
    labs(x = "No. of Reads", y = "No. of Replicates")
}

# Read in read counts --------------------------------------------------
may2022_read_counts <- read_tsv(
    inp$may2022_read_counts, 
    col_types = cols(.default = col_integer(), sample = col_character()), 
    progress = FALSE
  ) %>%
  rename(sample_id = sample)
may2022_read_counts_byloc <- may2022_read_counts %>%
  select(
    -`__no_feature`, 
    -`__ambiguous`, 
    -`__too_low_aQual`, 
    -`__not_aligned`, 
    -`__alignment_not_unique`
  ) %>%
  pivot_longer(-sample_id, names_to = "locus", values_to = "n_read")

# Plot distribution of failed reads by reason --------------------------
plot_failed_reads(may2022_read_counts)
```

These histograms show the number of replicates with a certain number of reads 
that failed for each reason identified by AmpSeQC. There are quite a few reads 
that failed because of the "no\_feature" condition, which, according to the
`htseq-count` documentation, means that they aligned to the reference but did
not correspond to any of the provided features.

The total number of reads that passed AmpSeQC's filters is:

```{r fig.width = 20, fig.height = 13}
read_count_heatmap <- function(reads, 
                               fill_scale = scale_fill_fermenter(
                                 palette = "YlGnBu", 
                                 name = "Reads", 
                                 breaks = c(10, 100, 1000, 2000)
                               ), 
                               theme_tweaks = NULL, 
                               title_lbl = NULL) {
  ggplot(
      data = reads, 
      mapping = aes(x = locus, y = sample_id, fill = n_read)
    ) +
    geom_tile() +
    fill_scale +
    labs(x = "Locus", y = "Replicate", title = title_lbl) +
    theme(
      axis.text.x = element_text(angle = 90, hjust = 1), 
      legend.position = "bottom", 
      legend.key.width = unit(0.35, "in")
    ) +
    theme_tweaks
}

# Print total read count -----------------------------------------------
sum(may2022_read_counts_byloc$n_read)

# Plot read counts by locus and replicate ------------------------------
may2022_read_counts_byloc %>%
  read_count_heatmap()
```

This heatmap shows the number of reads identified for each locus/replicate
combination. It is expected that some loci will have no reads, as the primer set
used for this run was reduced relative to the original panel design. As for the
remaining loci, read counts vary to a substantial extent by replicate, but this
is also expected to some extent because several different library prep protocols
are represented in this figure. These are compared elsewhere.

## UCI 12/23

```{r message = FALSE}
# Read in read counts --------------------------------------------------
uci1223_read_counts <- read_tsv(
    inp$uci1223_read_counts, 
    col_types = cols(.default = col_integer(), sample = col_character()), 
    progress = FALSE
  ) %>%
  rename(sample_id = sample)
uci1223_read_counts_byloc <- uci1223_read_counts %>%
  select(
    -`__no_feature`, 
    -`__ambiguous`, 
    -`__too_low_aQual`, 
    -`__not_aligned`, 
    -`__alignment_not_unique`
  ) %>%
  pivot_longer(-sample_id, names_to = "locus", values_to = "n_read")

# Plot distribution of failed reads by reason --------------------------
plot_failed_reads(uci1223_read_counts)
```

These histograms show the number of replicates with a certain number of reads 
that failed for each reason identified by AmpSeQC. For all of the failure
conditions, the read counts are at or near 0, indicating no cause for concern.
Because the "no\_feature" category is essentially empty in this case, the reads
falling into that category for the May 2022 data were not investigated further.

The total number of reads that passed AmpSeQC's filters is:

```{r fig.width = 20, fig.height = 30}
# Print total read count -----------------------------------------------
sum(uci1223_read_counts_byloc$n_read)

# Plot read counts by locus and replicate ------------------------------
uci1223_read_counts_byloc %>%
  read_count_heatmap()
```

This heatmap shows the number of reads identified for each locus/replicate
combination. As above, some loci are expected to lack data because primers were
not included for those loci. Of the remaining loci, we obtained adequate read
counts for many replicates, but for many other replicates we obtained almost
nothing.

# Selected Loci

To select loci to include in the final panel, loci with good amplification in
both tests with field samples are identified. First, only loci with data in both
runs are considered.

```{r}
# Identify loci present in both datasets -------------------------------
may2022_loci_wdata <- may2022_read_counts_byloc %>%
  filter(n_read > 0) %$%
  locus
uci1223_loci_wdata <- uci1223_read_counts_byloc %>%
  filter(n_read > 0) %$%
  locus
loci_good_amp <- union(may2022_loci_wdata, uci1223_loci_wdata)
```

Then, the read count heatmaps are recreated showing only these loci.

```{r fig.width = 16, fig.height = 13}
may2022_read_counts_byloc %>%
  filter(locus %in% loci_good_amp) %>%
  read_count_heatmap()
```

```{r fig.width = 16, fig.height = 30}
uci1223_read_counts_byloc %>%
  filter(locus %in% loci_good_amp) %>%
  read_count_heatmap()
```

There are one or two loci in each run that consistently did not amplify well,
but they are not the same loci between runs. Therefore, we decided not to remove
any more loci. It has been demonstrated that all loci in this panel have
amplified well in at least one sequencing run, and we can hope that under
favorable conditions the set represented in these figures will all yield good
results.

There are `r length(loci_good_amp)` loci in this final set, and they are:

```{r}
loci_good_amp
```

```{r}
tibble(locus = loci_good_amp) %>%
  write_csv(out$loci_good_amp)
```

# Read Counts

## Serial Dilutions

```{r message = FALSE}
# Read in read counts --------------------------------------------------
serialdil_read_counts <- read_tsv(
    inp$serialdil_read_counts, 
    col_types = cols(.default = col_integer(), sample = col_character()), 
    progress = FALSE
  ) %>%
  rename(sample_id = sample)
serialdil_read_counts_byloc <- serialdil_read_counts %>%
  select(
    -`__no_feature`, 
    -`__ambiguous`, 
    -`__too_low_aQual`, 
    -`__not_aligned`, 
    -`__alignment_not_unique`
  ) %>%
  pivot_longer(-sample_id, names_to = "locus", values_to = "n_read")
```

The read counts table includes all of the old loci because those were in the
files passed to AmpSeQC, but none of them should have been included in this
version of the panel. None of those loci received any reads in this run, which
verifies this is true:

```{r}
# Make sure none of old loci were included -----------------------------
serialdil_read_counts_byloc %>%
  filter(! locus %in% loci_good_amp) %$%
  sum(n_read)
serialdil_read_counts_byloc <- serialdil_read_counts_byloc %>%
  filter(locus %in% loci_good_amp)
```

```{r}
plot_failed_reads(serialdil_read_counts)
```

These histograms show the number of replicates with a certain number of reads 
that failed for each reason identified by AmpSeQC. For all of the failure
conditions, the read counts are at or near 0, indicating no cause for concern.

The total number of reads that passed AmpSeQC's filters is:

```{r fig.width = 14, fig.height = 5.5}
# Print total read count -----------------------------------------------
sum(serialdil_read_counts_byloc$n_read)

# Read in and join metadata sheet --------------------------------------
serialdil_read_counts_byloc <- serialdil_read_counts_byloc %>%
  separate_wider_delim(sample_id, "_", names = c("sample_id", NA, NA)) %>%
  separate_wider_delim(
    sample_id, 
    "-", 
    names = c("specimen_id", "parasitemia", "rep_id"), 
    cols_remove = FALSE
  ) %>%
  mutate(parasitemia = as.integer(parasitemia))

# Plot read counts by locus and replicate ------------------------------
for (s in unique(serialdil_read_counts_byloc$specimen_id)) {
  title_lbl <- str_c("Sample", str_sub(s, start = 2L), sep = " ")
  serialdil_read_counts_byloc %>%
    filter(specimen_id == s) %>%
    arrange(parasitemia, desc(rep_id)) %>%
    mutate(
      sample_id = factor(sample_id, levels = unique(sample_id), ordered = TRUE)
    ) %>%
    read_count_heatmap(
       fill_scale = scale_fill_fermenter(
         palette = "YlGnBu", 
         name = "Reads", 
         breaks = c(1, 10, 100, 1000, 2000)
       ), 
      title_lbl = title_lbl
    ) %>%
    print()
}
```

These heatmaps shows the number of reads identified for each locus/replicate
combination, one heatmap per sample in the serial dilution experiment.

From these plots, we can see that read counts generally diminish with decreasing
parasitemia, as expected, but the relationship is complex. For 250, 500, and
1000, there are some samples where all three replicates worked well overall, and
other samples where the results were more spotty. For 10, 50, and 100, some
samples worked well with some replicates and not others, and some samples didn't
work well at all. Also, samples five and six generally seem to have amplified
worse than the others, even once you account for the fact that they did not have
the highest parasitemia classes.

```{r fig.height = 3.5}
# Bind all sequencing runs into one tibble -----------------------------
may2022_read_counts_byloc <- may2022_read_counts_byloc %>%
  mutate(run = "may2022")
uci1223_read_counts_byloc <- uci1223_read_counts_byloc %>%
  mutate(run = "uci1223")
serialdil_read_counts_byloc <- serialdil_read_counts_byloc %>%
  select(-specimen_id, -parasitemia, -rep_id) %>%
  mutate(run = "serialdil")
read_counts_byloc <- bind_rows(
    may2022_read_counts_byloc, 
    uci1223_read_counts_byloc, 
    serialdil_read_counts_byloc
  ) %>%
  filter(locus %in% loci_good_amp)

# Compare amplification in this sequencing run to previous ones --------
mean_reads_per_sample <- read_counts_byloc %>%
  group_by(run, locus) %>%
  summarize(mean_reads_per_sample = mean(n_read), .groups = "drop")
mean_reads_per_sample %>%
  # Add a small decimal to every mean so that 0 will not become NA with 
  # a log transformation, but everything will still bin with the same 
  # integer
  mutate(mean_reads_per_sample = mean_reads_per_sample + 0.1) %>%
  ggplot(mapping = aes(x = mean_reads_per_sample)) +
  geom_histogram(bins = 30) +
  facet_wrap(vars(run)) +
  scale_x_continuous(trans = "log10") +
  labs(x = "Mean Reads per Sample", y = "No. of Loci")
```

These histograms show the mean reads per sample for each locus, with facets
separating results for each of the three sequencing runs analyzed above. The 
serial dilution experiment did yield fewer reads for many loci, which is not 
necessarily unexpected given the intentionally low parasite densities.

However, a larger number of loci had very few reads, compared to previous 
sequencing experiments. In addition, three loci completely failed, which has not 
happened before:

```{r}
mean_reads_per_sample %>%
  filter(mean_reads_per_sample < 10)
```

Also, loci that amplify badly continue to be inconsistent between different 
runs. PvP01_07_v1_500001_500200 failed in the May 2022 experiment, and has been 
fine since. PvP01_08_v1_1279701_1279900 and pvdbp.503 amplified badly (though 
not a complete failure) in Lauren's data, and were OK in the other two runs. In
the serial dilutions, six loci that have previously been OK either completely
failed or yielded very low reads.
